# ************************************************************
# Copyright (c) 2021, Kyle Williams - All Rights Reserved.
# You may use, distribute and modify this code under the
# terms of the BSD-3 license. You should have received a copy
# of the BSD-3 license with this file.
# If not, visit: https://opensource.org/licenses/BSD-3-Clause
# ************************************************************

from numpy import array

from utilities import *


## This class contains all information local to a sensor.
# The sensor is able to compute its movement given a model
# of motion. Positions/velocities are not updated unless
# update is called, in case the timestep is subdivided and
# positions need to be recomputed. Update should be called
# when moving to the next timestep.
# Note that velocity is stored in polar form (rho, theta).
class Sensor:
    ## Initialize Sensor.
    # Position as (x, y), velocity as (vx, vy)
    # boundary_sensor indicates that it is part of the fence.
    def __init__(self, position, vel, sensing_radius, boundary_sensor=False):
        self.pos = position
        self.old_pos = position
        self.vel = vel
        self.old_vel = vel
        self.radius = sensing_radius
        self.boundary_flag = boundary_sensor

    ## Update sensor current state.
    # This function updates the values on which the new position are computed,
    # It should not be called until ready to move to next timestep.
    def update(self):
        if self.boundary_flag:
            return
        self.old_pos = self.pos
        self.old_vel = self.vel

    ## Compute distance between two sensors.
    def dist(self, s2):
        return norm(array(self.old_pos) - array(s2.old_pos))


## This class represents a collection of sensors.
# A sensor network is a collection of sensors + motion model for how those
# sensors move.
# This class allows users to iterate over each sensor so that each sensor
# can be polled for information.
# We can iterate over an entire sensor network, or we can iterate over the
# mobile or fence sensors specifically.
# move() will compute any nonlocal computation from the motion model, and then
# move each sensor.
# Update() will update each sensor.
class SensorNetwork:

    ## Initialize sensor network.
    # Users can provide the positions and velocities of each sensor manually.
    # they should both be a list of tuples using cartesian coordinates. If the velocities
    # are not specified, then they will be initialized by the motion model using the vel_mag
    # parameter. If positions are not specified, they will be generated by the motion models'
    # domain using the n_sensors parameter.
    def __init__(self, motion_model, domain, sensing_radius, n_sensors=0, vel_mag=None, points=(), velocities=()):
        assert not velocities or len(points) == len(velocities), (
            'len(points) != len(velocities)'
        )

        assert not (n_sensors and points) or len(points) == n_sensors, (
            'The number points specified is different than the number of points provided'
        )

        self.motion_model = motion_model
        self.sensing_radius = sensing_radius

        # Initialize sensor positions
        if points:
            velocities = (self.motion_model.initial_vel(vel_mag) for _ in points)
        else:
            points = motion_model.domain.point_generator(n_sensors)
            velocities = (self.motion_model.initial_vel(vel_mag) for _ in points)

        self.mobile_sensors = [Sensor(pt, v, sensing_radius) for pt, v in zip(points, velocities)]
        self.fence_sensors = [Sensor(pt, (0, 0), sensing_radius, True) for pt in domain.fence]

    def __iter__(self):
        # WARNING: fence sensors must come first in order to compute alpha-cycle.
        return iter(self.fence_sensors + self.mobile_sensors)

    def move(self, dt):
        self.motion_model.nonlocal_update(self, dt)

        for sensor in self.mobile_sensors:
            self.motion_model.local_update(sensor, dt)

    ## Update each sensor's position.
    # This should be called before moving to the next timestep.
    def update(self):
        for s in self.mobile_sensors:
            s.update()

    @property
    def points(self):
        return [s.pos for s in self]
